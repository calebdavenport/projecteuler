#!/usr/bin/python3

"""
Cyclical figurate numbers
Problem 61

Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are
all figurate (polygonal) numbers and are generated by the following formulae:

    Triangle        P3,n=n(n+1)/2       1, 3, 6, 10, 15, ...
    Square          P4,n=n2             1, 4, 9, 16, 25, ...
    Pentagonal      P5,n=n(3n−1)/2      1, 5, 12, 22, 35, ...
    Hexagonal       P6,n=n(2n−1)        1, 6, 15, 28, 45, ...
    Heptagonal      P7,n=n(5n−3)/2      1, 7, 18, 34, 55, ...
    Octagonal       P8,n=n(3n−2)        1, 8, 21, 40, 65, ...

The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three
interesting properties.

    The set is cyclic, in that the last two digits of each number is the first
      two digits of the next number (including the last number with the first).
    Each polygonal type: tri (P3,127=8128), square (P4,91=8281), and
      pentagonal (P5,44=2882), is represented by a different number in the set.
    This is the only set of 4-digit numbers with this property.

Find the sum of the only ordered set of six cyclic 4-digit numbers for which
each polygonal type: tri, square, pentagonal, hexagonal, heptagonal, and
octagonal, is represented by a different number in the set.
"""


tuple_sets = []
final_order = [None for i in range(6)]
final_sum = 0


def main():
    for i in ([n*(n+1)//2 for n in range(150)],
              [n*n for n in range(150)],
              [n*(3*n-1)//2 for n in range(150)],
              [n*(2*n-1) for n in range(150)],
              [n*(5*n-3)//2 for n in range(150)],
              [n*(3*n-2) for n in range(150)]):
        # Only include numbers between 1000 and 9999
        i[:] = [x for x in i if (x in range(1000, 10000))]

        # Remove values XX0X since 0XXX is a 3 digit number
        i[:] = [x for x in i if (str(x)[-2] is not "0")]

        tuple_sets.append([(x // 100, x % 100) for x in i])

    # Start recursive function to find correct path
    find_next_number(to_check=[0, 1, 2, 3, 4, 5])

    for i in final_order:
        global final_sum
        final_sum += i[0]
    final_sum += final_sum * 100
    print(final_sum)
    return


def find_next_number(to_check=None, shared=None, start_tuple=None):
    if len(to_check) == 0:
        if start_tuple[0] == shared:
            # Return something other than None only if:
            #   1. There is some path going from the first to last element
            #   2. The last element can go to the first element
            return shared
        return None
    # i controls which number list to look through
    for i in to_check[::-1]:
        # j is the tuple that is currently being checked.
        for j in tuple_sets[i]:
            # Store the result into global variable to be used later
            final_order[i] = j
            if i == 5:
                # At the start of a cycle, ensure that the last element has
                #   something to compare to
                start_tuple = j
            # A match in the next list is found (or first list being checked
            if j[0] == shared or shared is None:
                # Disallow checking a list that is already in the cycle
                new_check = [x for x in to_check if (x is not i)]
                fn = find_next_number(to_check=new_check,
                                      shared = j[1],
                                      start_tuple = start_tuple)
                if fn:
                    # Returning since a deeper function call found the cycle
                    return start_tuple
                continue
    return None


if __name__ == "__main__":
    main()
